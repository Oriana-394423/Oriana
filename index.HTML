import React, { useRef, useEffect, useState } from "react";

// Single-file React component (default export)
// Tailwind CSS utility classes are used for layout and styling.
// This file is meant to be placed into a React app (e.g. Vite, Create React App)

export default function OrianaVolleyballProfile() {
  const canvasRef = useRef(null);
  const [running, setRunning] = useState(true);
  const [scoreA, setScoreA] = useState(0);
  const [scoreB, setScoreB] = useState(0);
  const [message, setMessage] = useState("Move mouse to aim. Click to hit the ball as Oriana!");

  // Team split (5 vs 5). One side includes Oriana.
  const teamLeft = ["Allison", "Harper", "Lauren", "Charlotte", "Emily"]; // left side
  const teamRight = ["Parker", "Jazmine", "Chloe", "Bella", "Oriana"]; // right side (Oriana)

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    canvas.width = 960;
    canvas.height = 520;

    // Game state
    const net = { x: canvas.width / 2 - 4, width: 8, color: "#d1b000" };
    const gravity = 0.35;
    let lastTime = performance.now();

    // Players as simple objects
    function makePlayers(names, leftSide) {
      const players = [];
      const spacing = canvas.width / (names.length + 1);
      names.forEach((n, i) => {
        const x = leftSide ? (spacing * (i + 1) * 0.9) : (canvas.width / 2 + spacing * (i + 1) * 0.9);
        const y = leftSide ? canvas.height - 110 : canvas.height - 110;
        players.push({ name: n, x, y, r: 20, isUser: n === "Oriana" });
      });
      return players;
    }

    const playersLeft = makePlayers(teamLeft, true);
    const playersRight = makePlayers(teamRight, false);
    const allPlayers = [...playersLeft, ...playersRight];

    // Find Oriana object
    const ori = allPlayers.find(p => p.name === "Oriana");

    // Ball
    const ball = {
      x: canvas.width / 2,
      y: 140,
      vx: 2 * (Math.random() > 0.5 ? 1 : -1),
      vy: 1,
      r: 12,
      color: "#f7c948",
    };

    // Simple AI bot targetting: each bot will try to move under the ball
    function updateBots(dt) {
      const bots = allPlayers.filter(p => !p.isUser);
      bots.forEach((b, i) => {
        // target position horizontally based on ball and side
        const sideCenter = b.x < canvas.width / 2 ? canvas.width * 0.25 : canvas.width * 0.75;
        const targetX = Math.max(60, Math.min(canvas.width - 60, ball.x + (Math.random() * 40 - 20)));
        const speed = 60 + Math.random() * 50; // px per second
        const dx = targetX - b.x;
        b.x += Math.sign(dx) * Math.min(Math.abs(dx), speed * dt);
      });
    }

    let mouse = { x: ori.x, y: ori.y - 40, down: false };

    function applyHit(player) {
      // If ball is near player, apply an impulse away from the player toward the other side.
      const dx = ball.x - player.x;
      const dy = ball.y - (player.y - 20);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 60) {
        const power = 8 + Math.random() * 4;
        const nx = dx / (dist || 1);
        const ny = dy / (dist || 1);
        // send ball roughly over the net depending on side
        const direction = player.x < canvas.width / 2 ? 1 : -1;
        ball.vx = nx * power + direction * 3;
        ball.vy = ny * power - 6; // upward
        setMessage(`${player.name} hits the ball!`);
      }
    }

    // Mouse controls: clicking will make Oriana hit
    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    }
    function onClick(e) {
      // If Oriana is close enough, hit
      applyHit(ori);
    }

    canvas.addEventListener("mousemove", onMouseMove);
    canvas.addEventListener("click", onClick);

    function resetBall(side) {
      ball.x = canvas.width / 2;
      ball.y = 140;
      ball.vx = 2 * (Math.random() > 0.5 ? 1 : -1);
      ball.vy = 0;
    }

    function update(dt) {
      // dt in seconds
      updateBots(dt);

      // physics
      ball.vy += gravity;
      ball.x += ball.vx * dt * 60;
      ball.y += ball.vy * dt * 60;

      // floor collisions
      if (ball.y + ball.r > canvas.height - 40) {
        ball.y = canvas.height - 40 - ball.r;
        ball.vy *= -0.6;
        ball.vx *= 0.98;

        // determine which side touched floor -> point
        if (ball.x < canvas.width / 2) {
          // point to right side
          setScoreB(s => s + 1);
          setMessage("Point for the right side!");
          resetBall('right');
        } else {
          setScoreA(s => s + 1);
          setMessage("Point for the left side!");
          resetBall('left');
        }
      }

      // walls
      if (ball.x - ball.r < 10) {
        ball.x = 10 + ball.r;
        ball.vx *= -0.9;
      }
      if (ball.x + ball.r > canvas.width - 10) {
        ball.x = canvas.width - 10 - ball.r;
        ball.vx *= -0.9;
      }

      // net collision (simple)
      if (ball.x > net.x - 20 && ball.x < net.x + net.width + 20 && ball.y + ball.r > canvas.height - 120) {
        // bounce back a bit
        ball.vy = -Math.abs(ball.vy) * 0.6 - 2;
        ball.vx *= -0.7;
        setMessage("The ball hit the net!");
      }

      // bots and player hit detection automatic (bots)
      allPlayers.forEach(p => {
        // if ball near player and moving toward them, bots may hit
        const dx = ball.x - p.x;
        const dy = ball.y - (p.y - 20);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (!p.isUser && dist < 36 && Math.abs(ball.vx) > 0.5) {
          // bot hit
          const power = 7 + Math.random() * 5;
          const nx = dx / (dist || 1);
          const ny = dy / (dist || 1);
          const direction = p.x < canvas.width / 2 ? 1 : -1;
          ball.vx
